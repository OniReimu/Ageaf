#!/usr/bin/env node

import { createInterface } from "node:readline";

function write(value) {
  process.stdout.write(`${JSON.stringify(value)}\n`);
}

function hasOwn(value, key) {
  return (
    value &&
    typeof value === "object" &&
    Object.prototype.hasOwnProperty.call(value, key)
  );
}

function requireKeys(value, keys) {
  return keys.every((key) => hasOwn(value, key));
}

const args = process.argv.slice(2);
if (args.includes("--version")) {
  process.stdout.write("0.0.0-test\n");
  process.exit(0);
}

if (args[0] !== "app-server") {
  process.stderr.write(`Unknown args: ${args.join(" ")}\n`);
  process.exit(1);
}

const rl = createInterface({ input: process.stdin, crlfDelay: Infinity });
let nextThread = 0;
const knownThreads = new Set();

rl.on("line", (line) => {
  let msg;
  try {
    msg = JSON.parse(line);
  } catch {
    return;
  }

  if (!msg || typeof msg !== "object") return;

  if (msg.id && msg.method === "initialize") {
    write({ id: msg.id, result: { ok: true } });
    return;
  }

  if (msg.method === "initialized") {
    return;
  }

  if (msg.id && msg.method === "thread/start") {
    const required = [
      "model",
      "modelProvider",
      "cwd",
      "approvalPolicy",
      "sandbox",
      "config",
      "baseInstructions",
      "developerInstructions",
      "experimentalRawEvents",
    ];
    if (!requireKeys(msg.params, required)) {
      write({ id: msg.id, error: { message: "invalid thread/start params" } });
      return;
    }
    nextThread += 1;
    const threadId = `thread-${nextThread}`;
    knownThreads.add(threadId);
    write({ id: msg.id, result: { thread: { id: threadId } } });
    return;
  }

  if (msg.id && msg.method === "turn/start") {
    const required = [
      "threadId",
      "input",
      "cwd",
      "approvalPolicy",
      "sandboxPolicy",
      "model",
      "effort",
      "summary",
      "outputSchema",
      "collaborationMode",
    ];
    if (!requireKeys(msg.params, required)) {
      write({ id: msg.id, error: { message: "invalid turn/start params" } });
      return;
    }
    const threadId = msg.params?.threadId ?? msg.params?.thread_id ?? "thread-1";
    if (!knownThreads.has(threadId)) {
      write({ id: msg.id, error: { message: "unknown threadId" } });
      return;
    }

    const turnId = "turn-1";
    const compactionItemId = "compaction-1";
    write({ id: msg.id, result: { ok: true } });
    write({ method: "turn/started", params: { threadId, turn: { id: turnId } } });

    write({
      method: "turn/error",
      params: {
        threadId,
        turnId,
        error: {
          message:
            "Codex ran out of room in the model's context window. Start a new thread or clear earlier history before retrying.",
        },
        willRetry: true,
      },
    });

    write({ method: "compaction/started", params: { threadId, itemId: compactionItemId } });
    write({ method: "thread/compacted", params: { threadId, itemId: compactionItemId } });
    write({ method: "compaction/completed", params: { threadId, itemId: compactionItemId } });

    write({
      method: "item/agentMessage/delta",
      params: {
        threadId,
        itemId: "item-1",
        delta: "Recovered after compaction",
      },
    });
    write({
      method: "thread/tokenUsage/updated",
      params: {
        threadId,
        tokenUsage: {
          total: { totalTokens: 28 },
          modelContextWindow: 200000,
        },
      },
    });
    write({ method: "turn/completed", params: { threadId, turn: { id: turnId } } });
    return;
  }

  if (msg.id) {
    write({ id: msg.id, result: { ok: true } });
  }
});
